// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

import { ERC721System } from "../../systems/eve-erc721-puppet/ERC721System.sol";
import { revertWithBytes } from "@latticexyz/world/src/revertWithBytes.sol";
import { IWorldCall } from "@latticexyz/world/src/IWorldKernel.sol";
import { SystemCall } from "@latticexyz/world/src/SystemCall.sol";
import { Systems } from "@latticexyz/world/src/codegen/tables/Systems.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";

type ERC721SystemType is bytes32;

// equivalent to WorldResourceIdLib.encode({ typeId: RESOURCE_SYSTEM, namespace: "evefrontier", name: "ERC721System" }))
ERC721SystemType constant eRC721System = ERC721SystemType.wrap(
  0x737965766566726f6e7469657200000045524337323153797374656d00000000
);

struct CallWrapper {
  ResourceId systemId;
  address from;
}

struct RootCallWrapper {
  ResourceId systemId;
  address from;
}

/**
 * @title ERC721SystemLib
 * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)
 * @dev This library is automatically generated from the corresponding system contract. Do not edit manually.
 */
library ERC721SystemLib {
  error ERC721SystemLib_CallingFromRootSystem();

  function balanceOf(ERC721SystemType self, address owner) internal view returns (uint256) {
    return CallWrapper(self.toResourceId(), address(0)).balanceOf(owner);
  }

  function ownerOf(ERC721SystemType self, uint256 tokenId) internal view returns (address) {
    return CallWrapper(self.toResourceId(), address(0)).ownerOf(tokenId);
  }

  function name(ERC721SystemType self) internal view returns (string memory) {
    return CallWrapper(self.toResourceId(), address(0)).name();
  }

  function symbol(ERC721SystemType self) internal view returns (string memory) {
    return CallWrapper(self.toResourceId(), address(0)).symbol();
  }

  function tokenURI(ERC721SystemType self, uint256 tokenId) internal view returns (string memory) {
    return CallWrapper(self.toResourceId(), address(0)).tokenURI(tokenId);
  }

  function approve(ERC721SystemType self, address to, uint256 tokenId) internal {
    return CallWrapper(self.toResourceId(), address(0)).approve(to, tokenId);
  }

  function getApproved(ERC721SystemType self, uint256 tokenId) internal view returns (address) {
    return CallWrapper(self.toResourceId(), address(0)).getApproved(tokenId);
  }

  function setApprovalForAll(ERC721SystemType self, address operator, bool approved) internal {
    return CallWrapper(self.toResourceId(), address(0)).setApprovalForAll(operator, approved);
  }

  function isApprovedForAll(ERC721SystemType self, address owner, address operator) internal view returns (bool) {
    return CallWrapper(self.toResourceId(), address(0)).isApprovedForAll(owner, operator);
  }

  function transferFrom(ERC721SystemType self, address from, address to, uint256 tokenId) internal {
    return CallWrapper(self.toResourceId(), address(0)).transferFrom(from, to, tokenId);
  }

  function safeTransferFrom(ERC721SystemType self, address from, address to, uint256 tokenId) internal {
    return CallWrapper(self.toResourceId(), address(0)).safeTransferFrom(from, to, tokenId);
  }

  function safeTransferFrom(
    ERC721SystemType self,
    address from,
    address to,
    uint256 tokenId,
    bytes memory data
  ) internal {
    return CallWrapper(self.toResourceId(), address(0)).safeTransferFrom(from, to, tokenId, data);
  }

  function mint(ERC721SystemType self, address to, uint256 tokenId) internal {
    return CallWrapper(self.toResourceId(), address(0)).mint(to, tokenId);
  }

  function safeMint(ERC721SystemType self, address to, uint256 tokenId) internal {
    return CallWrapper(self.toResourceId(), address(0)).safeMint(to, tokenId);
  }

  function safeMint(ERC721SystemType self, address to, uint256 tokenId, bytes memory data) internal {
    return CallWrapper(self.toResourceId(), address(0)).safeMint(to, tokenId, data);
  }

  function burn(ERC721SystemType self, uint256 tokenId) internal {
    return CallWrapper(self.toResourceId(), address(0)).burn(tokenId);
  }

  function balanceOf(CallWrapper memory self, address owner) internal view returns (uint256) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.balanceOf")), owner);
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (uint256));
  }

  function ownerOf(CallWrapper memory self, uint256 tokenId) internal view returns (address) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.ownerOf")), tokenId);
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (address));
  }

  function name(CallWrapper memory self) internal view returns (string memory) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.name")));
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (string));
  }

  function symbol(CallWrapper memory self) internal view returns (string memory) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.symbol")));
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (string));
  }

  function tokenURI(CallWrapper memory self, uint256 tokenId) internal view returns (string memory) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.tokenURI")), tokenId);
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (string));
  }

  function approve(CallWrapper memory self, address to, uint256 tokenId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.approve")), to, tokenId);
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function getApproved(CallWrapper memory self, uint256 tokenId) internal view returns (address) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.getApproved")), tokenId);
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (address));
  }

  function setApprovalForAll(CallWrapper memory self, address operator, bool approved) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.setApprovalForAll")),
      operator,
      approved
    );
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function isApprovedForAll(CallWrapper memory self, address owner, address operator) internal view returns (bool) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.isApprovedForAll")),
      owner,
      operator
    );
    bytes memory worldCall = self.from == address(0)
      ? abi.encodeCall(IWorldCall.call, (self.systemId, systemCall))
      : abi.encodeCall(IWorldCall.callFrom, (self.from, self.systemId, systemCall));
    (bool success, bytes memory returnData) = address(_world()).staticcall(worldCall);
    if (!success) revertWithBytes(returnData);

    bytes memory result = abi.decode(returnData, (bytes));
    return abi.decode(result, (bool));
  }

  function transferFrom(CallWrapper memory self, address from, address to, uint256 tokenId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.transferFrom")), from, to, tokenId);
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function safeTransferFrom(CallWrapper memory self, address from, address to, uint256 tokenId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.safeTransferFrom")),
      from,
      to,
      tokenId
    );
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function safeTransferFrom(
    CallWrapper memory self,
    address from,
    address to,
    uint256 tokenId,
    bytes memory data
  ) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.safeTransferFrom")),
      from,
      to,
      tokenId,
      data
    );
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function mint(CallWrapper memory self, address to, uint256 tokenId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.mint")), to, tokenId);
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function safeMint(CallWrapper memory self, address to, uint256 tokenId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.safeMint")), to, tokenId);
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function safeMint(CallWrapper memory self, address to, uint256 tokenId, bytes memory data) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.safeMint")), to, tokenId, data);
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function burn(CallWrapper memory self, uint256 tokenId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert ERC721SystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.burn")), tokenId);
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function balanceOf(RootCallWrapper memory self, address owner) internal view returns (uint256) {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.balanceOf")), owner);

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (uint256));
  }

  function ownerOf(RootCallWrapper memory self, uint256 tokenId) internal view returns (address) {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.ownerOf")), tokenId);

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (address));
  }

  function name(RootCallWrapper memory self) internal view returns (string memory) {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.name")));

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (string));
  }

  function symbol(RootCallWrapper memory self) internal view returns (string memory) {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.symbol")));

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (string));
  }

  function tokenURI(RootCallWrapper memory self, uint256 tokenId) internal view returns (string memory) {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.tokenURI")), tokenId);

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (string));
  }

  function approve(RootCallWrapper memory self, address to, uint256 tokenId) internal {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.approve")), to, tokenId);
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function getApproved(RootCallWrapper memory self, uint256 tokenId) internal view returns (address) {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.getApproved")), tokenId);

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (address));
  }

  function setApprovalForAll(RootCallWrapper memory self, address operator, bool approved) internal {
    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.setApprovalForAll")),
      operator,
      approved
    );
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function isApprovedForAll(RootCallWrapper memory self, address owner, address operator) internal view returns (bool) {
    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.isApprovedForAll")),
      owner,
      operator
    );

    bytes memory result = SystemCall.staticcallOrRevert(self.from, self.systemId, systemCall);
    return abi.decode(result, (bool));
  }

  function transferFrom(RootCallWrapper memory self, address from, address to, uint256 tokenId) internal {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.transferFrom")), from, to, tokenId);
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function safeTransferFrom(RootCallWrapper memory self, address from, address to, uint256 tokenId) internal {
    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.safeTransferFrom")),
      from,
      to,
      tokenId
    );
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function safeTransferFrom(
    RootCallWrapper memory self,
    address from,
    address to,
    uint256 tokenId,
    bytes memory data
  ) internal {
    bytes memory systemCall = abi.encodeWithSelector(
      bytes4(keccak256("ERC721System.safeTransferFrom")),
      from,
      to,
      tokenId,
      data
    );
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function mint(RootCallWrapper memory self, address to, uint256 tokenId) internal {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.mint")), to, tokenId);
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function safeMint(RootCallWrapper memory self, address to, uint256 tokenId) internal {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.safeMint")), to, tokenId);
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function safeMint(RootCallWrapper memory self, address to, uint256 tokenId, bytes memory data) internal {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.safeMint")), to, tokenId, data);
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function burn(RootCallWrapper memory self, uint256 tokenId) internal {
    bytes memory systemCall = abi.encodeWithSelector(bytes4(keccak256("ERC721System.burn")), tokenId);
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function callFrom(ERC721SystemType self, address from) internal pure returns (CallWrapper memory) {
    return CallWrapper(self.toResourceId(), from);
  }

  function callAsRoot(ERC721SystemType self) internal view returns (RootCallWrapper memory) {
    return RootCallWrapper(self.toResourceId(), msg.sender);
  }

  function callAsRootFrom(ERC721SystemType self, address from) internal pure returns (RootCallWrapper memory) {
    return RootCallWrapper(self.toResourceId(), from);
  }

  function toResourceId(ERC721SystemType self) internal pure returns (ResourceId) {
    return ResourceId.wrap(ERC721SystemType.unwrap(self));
  }

  function fromResourceId(ResourceId resourceId) internal pure returns (ERC721SystemType) {
    return ERC721SystemType.wrap(resourceId.unwrap());
  }

  function getAddress(ERC721SystemType self) internal view returns (address) {
    return Systems.getSystem(self.toResourceId());
  }

  function _world() private view returns (IWorldCall) {
    return IWorldCall(StoreSwitch.getStoreAddress());
  }
}

using ERC721SystemLib for ERC721SystemType global;
using ERC721SystemLib for CallWrapper global;
using ERC721SystemLib for RootCallWrapper global;
